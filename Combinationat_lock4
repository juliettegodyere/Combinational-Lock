--On clock rise, start counting at a very hign speed

entity test is
    CLK100MHZ: in std_logic;
    BTNL, BTNR, BTNU, BTND, BTNC: in std_logic;        --Push buttons
    SWITCHES:  in std_logic_vector (15 downto 0);       --Slider switches
    LEDS:      out std_logic_vector (7 downto 0);      --LEDs
    DIGITS:    out std_logic_vector (7 downto 0);      --Digits of 7-segment display
    SEGMENTS:  out std_logic_vector (7 downto 0)   );  --Segments of 7-segment display 
end test;

architecture Behavioral of test is
    signal passcode: std_logic_vector (15 downto 0):=X"0240"; --The four digit student ID
    signal user_ram_input: std_logic_vector (7 downto 0):=X"00"; --The two digit inputted by user
    signal user_ram_output: std_logic_vector (7 downto 0):=X"00"; --The two digit from passcode index of random1 and random2
    signal rand_no: std_logic_vector (7 downto 0):=X"00"; --The two digit random number
    signal ramdom_count1: std_logic_vector(3 downto 0);
    signal random_count2: std_logic_vector(3 downto 0);
    signal enable: std_logic; --Enable signal for the RAM
    signal freq_count: STD_LOGIC_VECTOR(15 downto 0):=(OTHERS=>'0') ; --Random number counter
    signal count: STD_LOGIC_VECTOR(15 downto 0):=(OTHERS=>'0') ; --The counter for the 1KHz clock
    signal dig_count: Integer:=0; -- Used as multiplexer for diplaying of multiple displays
    constant MAX_COUNT: std_logic_vector(15 downto 0) := "1100001101010000";  -- 100,000: use this for synthesis  --  "1010";  
    signal start_btnc_prev, accept_btnl_prev, debounced_btnb, debounced_btnl: std_logic :='0';
    type my_states IS (idle,s0, s1, s2, s3); -- id: idle, st:start, s0: input 1, s1: input 2, s2: input 3, s3: input 4, re: reset
    signal state: my_states:=idle; 

    begin
        process (enable)
        begin
            if rising_edge(enable) then
                start_btnb_prev = BTNB; -- assign BTNB value to start_btnb_prev
                accept_btnl_prev = BTNL; -- assign BTNL value to accept_btnl_prev
                --Check if the first button is pressed and compare the recent button value with the previous value
                if (BTNB = '1' and start_btnb_prev = '0')' then
                    case state is
                        when Idle => if debounced_btnc = '1' then state <= s0; 
                                    else state <= Idle; end if;
                        when s2 => if debounced_btnc = '1' then state <= idle; 
                                    else state <= s2; end if;
                        when others => state <= Idle;
                    end case;
                --Check if the second button is pressed and compare the recent button value with the previous value
                elsif BTNL = '1' and accept_btnl_prev = '0
                    case state is
                        when s0 => if debounced_btnl = '1' then state <= s1;  
                                    else state <= s0; end if;
                        when s1 => if debounced_btnl = '1' then state <= s2; 
                                    else state <= s1; end if;
                        when s2 => if debounced_btnl = '1' then state <= s0;  
                                    else state <= s2; end if;
                        when others => state <= Idle;
                    end case;
                else
                    state <= Idle;
                end if;
            end if;
        end process;

        process(clk500MHz)
        begin
            if rising_edge(clk100MHz) then
                start_btnb_prev = BTNB;
                accept_btnl_prev = BTNL;
               freq_count <= freq_count + "0000000000000001"; -- Randomly increment the counter
              
               if state = Idle then
                    if count = MAX_COUNT THEN  -- Count to 100,000 which is the maximum value for the counter
                        enable <= '1' ; 
                        count <= (others => '0') ;
                        LEDS <= "00000000"; -- Turn off unused LEDs
                        DIGITS <= "11111111"; -- Turn off all display digits
                    else  
                        enable <= '0' ; 
                        count <= count + 1 ;  -- Increment the counter
                    end if ;
               elsif state = s0 then
                    random1 <= freq_count(3 downto 0);
                    random2 <= freq_count(11 downto 8);
                    if (random1 = "0001" OR random1 = "0010" OR random1 = "0011" OR random1 = "0100") AND random1 /= random2 then
                        rand_no(7 downto 4) <= random1;
                    elsif (random2 = "0001" OR random2 = "0010" OR random2 = "0011" OR random2 = "0100") AND rand /= random1 then
                        rand_no(3 downto 0) <= random2;
                    end if;
                    if rand_no(3 downto 0) > rand_no(7 downto 4) then
                        rand_no(7 downto 4) <= random2;
                        rand_no(3 downto 0) <= random1;
                    end if;
                    if count = MAX_COUNT then
                        enable <= '1' ; 
                        count <= (others => '0') ;
                        -----Multiplexer: Display multiple values on the segment display-----
                        if dig_count = 0 then
                            --Display "N" on first digit of segment display
                            display_value <= rand_no(3 downto 0); 
                            DIGITS <= "11111110";
                        elsif dig_count = 1 then
                            --Display "0" on second digit of segment display
                            display_value <= rand_no(7 downto 4);
                            DIGITS <= "11111101"; -- Displays "0" on the second digit
                        end if;

                        --Count checker for the multiplexer
                        if dig_count > 1 then
                            dig_count <= 0;
                        else 
                            dig_count <= dig_count+1;
                        end if;
                        ------END Multiplexer-----
                        user_ram_input(7 downto 4) <= SWITCHES(7 downto 4);
                        user_ram_input(3 downto 0) <= SWITCHES(3 downto 0);

                    else
                        count <= count + 1;
                        enable <= '0' ;
                    end if;
                elsif state = s1 then
                    enable <= '1' ;
                    count <= (others => '0') ;
                     -----Multiplexer: Display multiple values on the segment display-----
                     if dig_count = 0 then
                        --Display "N" on first digit of segment display
                        display_value <= SWITCHES(3 downto 0); 
                        DIGITS <= "11111110";
                    elsif dig_count = 1 then
                        --Display "0" on second digit of segment display
                        display_value <= SWITCHES(7 downto 4);
                        DIGITS <= "11111101"; -- Displays "0" on the second digit
                    end if;

                    --Count checker for the multiplexer
                    if dig_count > 1 then
                        dig_count <= 0;
                    else 
                        dig_count <= dig_count+1;
                    end if;
                    ------END Multiplexer-----
                elsif state = s2 then
                    enable <= '1' ;
                    count <= (others => '0') ;
                    user_ram_output(7 downto 4) <= passcode(rand_no(7 downto 4));
                    user_ram_output(3 downto 0) <= passcode(rand_no(3 downto 0));
                    if user_ram_input = user_ram_output then
                        LEDS(7 downto 0) <= "11111111";
                        DIGITS <= "11111110"; 
                           if dig_count = 0 then
                              display_value <= "1011";
                              DIGITS <= "11111110"; --Displays "H" on the third digit
                           elsif dig_count = 1 then
                              display_value <= "0000";
                              DIGITS <= "11111101"; --Displays "O" on the third digit
                           end if;
                           if dig_count > 1 then
                              dig_count <= 0;
                           else 
                              dig_count <= dig_count+1;
                           end if;
                    else
                        LEDS(7 downto 0) <= "00000000";
                        if dig_count = 0 then
                            display_value <= "1100";
                            DIGITS <= "11111110";--Displays "r" on the third digit
                        elsif dig_count = 1 then
                            display_value <= "1100";
                            DIGITS <= "11111101";--Displays "r" on the third digit
                        elsif dig_count = 2 then
                            display_value <= "1110";
                            DIGITS <= "11111011";--Displays "E" on the third digit
                        end if;
                        if dig_count > 2 then
                            dig_count <= 0;
                        else 
                            dig_count <= dig_count+1;
                        end if;
                    end if;
                end if;

            end if;
        end process;

start_btn_debouncer: ENTITY work.Debouncer(Behavioral) PORT MAP(clk=>enable, D_BTNB=>start_btnb_prev, btnc_clr=>debounced_btnb);
accept_btn_debouncer: ENTITY work.Debounce(Behavioral) PORT MAP(clk=>enable, D_BTNL=>accept_btnl_prev, btnl_clr=>debounced_btnl);
display: ENTITY work.display(Behavioral) PORT MAP(number=> display_value, segs=> SEGMENTS);